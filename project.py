# -*- coding: utf-8 -*-
"""Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cs5BQLSKf1MSTFX9Jbwj8JFraRnPwm2R

LSTM Model
"""

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout, Input
from tensorflow.keras.callbacks import ReduceLROnPlateau, EarlyStopping, ModelCheckpoint

# Download Apple data from Yahoo Finance
symbol = "AAPL"
start_date = "2016-07-31"
end_date = "2024-12-31"

data = yf.download(symbol, start=start_date, end=end_date)
data = data[['Open']]
# Define training and validation periods
train_start_date = '2016-07-31'
train_end_date = '2021-07-31'
val_start_date = '2021-08-01'
val_end_date = '2023-12-31'

# Define the three test periods
short_term_start = '2024-01-01'
short_term_end = '2024-03-01'

medium_term_start = '2024-01-01'
medium_term_end = '2024-07-01'

long_term_start = '2024-01-01'
long_term_end = '2024-10-01'

# Split data
train_data = data.loc[train_start_date:train_end_date]
val_data = data.loc[val_start_date:val_end_date]
short_term_data = data.loc[short_term_start:short_term_end]
medium_term_data = data.loc[medium_term_start:medium_term_end]
long_term_data = data.loc[long_term_start:long_term_end]

# Plot data splits
plt.figure(figsize=(14, 7))
plt.plot(data.index, data['Open'], label='AAPL Open Values', color='lightgray')
plt.plot(train_data.index, train_data['Open'], label='Training Period', color='blue')
plt.plot(val_data.index, val_data['Open'], label='Validation Period', color='orange')
plt.plot(short_term_data.index, short_term_data['Open'], label='Short-term Test (Jan-Mar 2024)', color='green')
plt.plot(medium_term_data.index, medium_term_data['Open'], label='Medium-term Test (Jan-Jul 2024)', color='red')
plt.plot(long_term_data.index, long_term_data['Open'], label='Long-term Test (Jan-Oct 2024)', color='purple')
plt.title('AAPL Open Values with Training, Validation, and Test Periods')
plt.xlabel('Date')
plt.ylabel('Open Value')
plt.legend()
plt.grid()
plt.show()

# Scale the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_train = scaler.fit_transform(train_data)
scaled_val = scaler.transform(val_data)
scaled_short_term = scaler.transform(short_term_data)
scaled_medium_term = scaler.transform(medium_term_data)
scaled_long_term = scaler.transform(long_term_data)

# Define sequence parameters
sequence_length = 5
pred_length = 5

# Create sequences for LSTM input
def create_sequences(data, seq_length=5, pred_length=5):
    X, y = [], []
    for i in range(len(data) - seq_length - pred_length + 1):
        X.append(data[i:i + seq_length])
        y.append(data[i + seq_length:i + seq_length + pred_length].reshape(pred_length))
    return np.array(X), np.array(y)

# Generate sequences for training, validation, and testing
X_train, y_train = create_sequences(scaled_train, sequence_length, pred_length)
X_val, y_val = create_sequences(scaled_val, sequence_length, pred_length)
X_short_term, y_short_term = create_sequences(scaled_short_term, sequence_length, pred_length)
X_medium_term, y_medium_term = create_sequences(scaled_medium_term, sequence_length, pred_length)
X_long_term, y_long_term = create_sequences(scaled_long_term, sequence_length, pred_length)

# Reshape X data for LSTM [samples, time steps, features]
X_train = X_train.reshape((X_train.shape[0], sequence_length, 1))
X_val = X_val.reshape((X_val.shape[0], sequence_length, 1))
X_short_term = X_short_term.reshape((X_short_term.shape[0], sequence_length, 1))
X_medium_term = X_medium_term.reshape((X_medium_term.shape[0], sequence_length, 1))
X_long_term = X_long_term.reshape((X_long_term.shape[0], sequence_length, 1))

# Check shapes
print("Training and Validation Shapes:")
print("X_train shape:", X_train.shape)
print("y_train shape:", y_train.shape)
print("X_val shape:", X_val.shape)
print("y_val shape:", y_val.shape)

print("\nTest Set Shapes:")
print("Short-term X shape:", X_short_term.shape)
print("Short-term y shape:", y_short_term.shape)
print("Medium-term X shape:", X_medium_term.shape)
print("Medium-term y shape:", y_medium_term.shape)
print("Long-term X shape:", X_long_term.shape)
print("Long-term y shape:", y_long_term.shape)

# Define the LSTM model
model = Sequential()
model.add(Input(shape=(sequence_length, 1)))
model.add(LSTM(200, activation='relu'))
model.add(Dense(100, activation='relu'))
model.add(Dropout(0.3))
model.add(Dense(50, activation='relu'))
model.add(Dense(pred_length))  # Output layer with pred_length predictions

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error')
model.summary()

# Define callbacks
lr_scheduler = ReduceLROnPlateau(
    monitor='val_loss',
    factor=0.5,
    patience=5,
    min_lr=1e-6
)

early_stopping = EarlyStopping(
    monitor='val_loss',
    patience=10,
    restore_best_weights=True
)

checkpoint = ModelCheckpoint(
    'best_model.keras',
    monitor='val_loss',
    save_best_only=True
)

# Train the model
history = model.fit(
    X_train, y_train,
    validation_data=(X_val, y_val),
    epochs=100,
    batch_size=32,
    callbacks=[lr_scheduler, early_stopping, checkpoint]
)

# Plot training & validation loss
plt.figure(figsize=(12, 6))
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.title('Training and Validation Loss')
plt.legend()
plt.grid()
plt.show()

# Function to evaluate model performance
def evaluate_model_performance(X, y, period_name):
    # Make predictions
    y_pred = model.predict(X)

    # Convert to original scale
    y_original = np.zeros((y.shape[0], pred_length))
    y_pred_original = np.zeros((y_pred.shape[0], pred_length))

    for i in range(y.shape[0]):
        # Reshape to column format required by scaler
        actual_seq = y[i].reshape(-1, 1)
        pred_seq = y_pred[i].reshape(-1, 1)

        # Inverse transform
        y_original[i] = scaler.inverse_transform(actual_seq).flatten()
        y_pred_original[i] = scaler.inverse_transform(pred_seq).flatten()

    # Calculate metrics
    mse = mean_squared_error(y_original.flatten(), y_pred_original.flatten())
    rmse = np.sqrt(mse)
    mae = mean_absolute_error(y_original.flatten(), y_pred_original.flatten())
    r2 = r2_score(y_original.flatten(), y_pred_original.flatten())

    # Calculate RMSE to Mean Ratio
    mean_y = np.mean(y_original)
    rmse_to_mean_ratio = rmse / mean_y

    # Output the error metrics
    print(f"\n{period_name} Test Results:")
    print("Mean Squared Error (MSE):", mse)
    print("Root Mean Squared Error (RMSE):", rmse)
    print("Mean Absolute Error (MAE):", mae)
    print("RMSE to Mean Ratio:", rmse_to_mean_ratio)
    print("R² (Coefficient of Determination):", r2)

    # Plot Actual vs Predicted
    plt.figure(figsize=(12, 6))
    plt.plot(y_original.flatten(), label='Actual')
    plt.plot(y_pred_original.flatten(), label='Predicted')
    plt.xlabel('Sample')
    plt.ylabel('Stock Price ($)')
    plt.title(f'Actual vs Predicted on {period_name} Test Set')
    plt.legend()
    plt.grid()
    plt.show()

    return {
        'mse': mse,
        'rmse': rmse,
        'mae': mae,
        'rmse_to_mean': rmse_to_mean_ratio,
        'r2': r2
    }

# Evaluate on validation set
val_metrics = evaluate_model_performance(X_val, y_val, "Validation")

# Evaluate on short-term test set
short_term_metrics = evaluate_model_performance(X_short_term, y_short_term, "Short-term (Jan-Mar 2024)")

# Evaluate on medium-term test set
medium_term_metrics = evaluate_model_performance(X_medium_term, y_medium_term, "Medium-term (Jan-Jul 2024)")

# Evaluate on long-term test set
long_term_metrics = evaluate_model_performance(X_long_term, y_long_term, "Long-term (Jan-Oct 2024)")

# Compare performance across different time horizons
metrics = ['MSE', 'RMSE', 'MAE', 'RMSE/Mean', 'R²']
periods = ['Validation', 'Short-term', 'Medium-term', 'Long-term']
values = [
    [val_metrics['mse'], val_metrics['rmse'], val_metrics['mae'], val_metrics['rmse_to_mean'], val_metrics['r2']],
    [short_term_metrics['mse'], short_term_metrics['rmse'], short_term_metrics['mae'], short_term_metrics['rmse_to_mean'], short_term_metrics['r2']],
    [medium_term_metrics['mse'], medium_term_metrics['rmse'], medium_term_metrics['mae'], medium_term_metrics['rmse_to_mean'], medium_term_metrics['r2']],
    [long_term_metrics['mse'], long_term_metrics['rmse'], long_term_metrics['mae'], long_term_metrics['rmse_to_mean'], long_term_metrics['r2']]
]

# Create comparison bar charts
fig, axs = plt.subplots(2, 2, figsize=(16, 12))
axs = axs.flatten()

for i, metric in enumerate(['MSE', 'RMSE', 'MAE', 'R²']):
    axs[i].bar(periods, [values[j][i] for j in range(len(periods))])
    axs[i].set_title(f'Comparison of {metric} Across Time Horizons')
    axs[i].set_ylabel(metric)
    axs[i].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Create a summary table of the results
print("\nPerformance Summary Across Time Horizons:")
print("-" * 80)
print(f"{'Metric':<15} {'Validation':<15} {'Short-term':<15} {'Medium-term':<15} {'Long-term':<15}")
print("-" * 80)
for i, metric in enumerate(metrics):
    print(f"{metric:<15} {values[0][i]:<15.4f} {values[1][i]:<15.4f} {values[2][i]:<15.4f} {values[3][i]:<15.4f}")
print("-" * 80)

"""Linear regression"""

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import math

# Define the symbol and the time period
symbol = "AAPL"
start_date = "2016-07-31"
end_date = "2024-10-02"

# Download the data
data = yf.download(symbol, start=start_date, end=end_date)

# Use only the 'Open' prices
data = data[['Open']]

# Create lagged features (previous day's price)
data['Prev_1'] = data['Open'].shift(1)

# Drop NaN values
data = data.dropna()

# Define the training and validation periods
train_start_date = '2016-07-31'
train_end_date = '2021-07-31'
val_start_date = '2021-08-01'
val_end_date = '2023-12-31'

# Define the three test periods
short_term_start = '2024-01-01'
short_term_end = '2024-03-01'
medium_term_start = '2024-01-01'
medium_term_end = '2024-07-01'
long_term_start = '2024-01-01'
long_term_end = '2024-10-01'

# Split the data
train_data = data.loc[train_start_date:train_end_date].copy()
val_data = data.loc[val_start_date:val_end_date].copy()
short_term_test = data.loc[short_term_start:short_term_end].copy()
medium_term_test = data.loc[medium_term_start:medium_term_end].copy()
long_term_test = data.loc[long_term_start:long_term_end].copy()

# Perform walk-forward validation on validation data
def walk_forward_validation(validation_data):
    # Initialize results dataframe with actual values
    results = validation_data.copy()
    results['Predicted'] = np.nan

    # Get initial training window end date (matches the full training dataset end date)
    cutoff_date = train_end_date

    # For each validation day
    for i in range(len(validation_data)):
        # Get current validation day
        current_date = validation_data.index[i]

        # Get all data up to cutoff date for training
        train_window = data.loc[:cutoff_date].copy()

        # Prepare training data
        X_train = train_window['Prev_1'].values.reshape(-1, 1)
        y_train = train_window['Open'].values

        # Train the model on data up to cutoff date
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Get previous value from validation data
        if i == 0:
            # For first prediction, use actual previous value
            prev_value = validation_data['Prev_1'].iloc[0]
        else:
            # For subsequent predictions, use the previous prediction
            prev_value = results['Predicted'].iloc[i-1]

        # Make prediction
        X_pred = np.array([prev_value]).reshape(1, -1)
        prediction = model.predict(X_pred)[0]

        # Store prediction
        results.loc[current_date, 'Predicted'] = prediction

        # Update cutoff date to include current validation day
        cutoff_date = current_date

    # Calculate metrics
    mse = mean_squared_error(results['Open'], results['Predicted'])
    rmse = math.sqrt(mse)
    mae = mean_absolute_error(results['Open'], results['Predicted'])
    r2 = r2_score(results['Open'], results['Predicted'])

    metrics = {
        'MSE': mse,
        'RMSE': rmse,
        'MAE': mae,
        'R2': r2
    }

    return results, metrics

# Test function for test periods
def test_model(test_data, training_end_date):
    # Initialize results dataframe
    results = test_data.copy()
    results['Predicted'] = np.nan

    # Get all data up to the last training/validation date for the model
    train_window = data.loc[:training_end_date].copy()

    # Prepare training data
    X_train = train_window['Prev_1'].values.reshape(-1, 1)
    y_train = train_window['Open'].values

    # Train the model
    model = LinearRegression()
    model.fit(X_train, y_train)

    # Get initial previous value
    prev_value = test_data['Prev_1'].iloc[0]

    # For each test day
    for i in range(len(test_data)):
        # Make prediction
        X_pred = np.array([prev_value]).reshape(1, -1)
        prediction = model.predict(X_pred)[0]

        # Store prediction
        results.iloc[i, results.columns.get_loc('Predicted')] = prediction

        # Use prediction as next previous value
        prev_value = prediction

    # Calculate metrics
    mse = mean_squared_error(results['Open'], results['Predicted'])
    rmse = math.sqrt(mse)
    mae = mean_absolute_error(results['Open'], results['Predicted'])
    r2 = r2_score(results['Open'], results['Predicted'])

    metrics = {
        'MSE': mse,
        'RMSE': rmse,
        'MAE': mae,
        'R2': r2
    }

    return results, metrics

# Perform walk-forward validation on validation data
print("Running walk-forward validation...")
val_results, val_metrics = walk_forward_validation(val_data)

# Test on the short-term test period
print("Running short-term test...")
short_term_results, short_term_metrics = test_model(short_term_test, val_end_date)

# Test on the medium-term test period
print("Running medium-term test...")
medium_term_results, medium_term_metrics = test_model(medium_term_test, val_end_date)

# Test on the long-term test period
print("Running long-term test...")
long_term_results, long_term_metrics = test_model(long_term_test, val_end_date)

# Print metrics
print("\nValidation Metrics (Walk-Forward Validation):")
for key, value in val_metrics.items():
    print(f"{key}: {value:.4f}")

print("\nShort-Term Test Metrics (Jan 2024 - Mar 2024):")
for key, value in short_term_metrics.items():
    print(f"{key}: {value:.4f}")

print("\nMedium-Term Test Metrics (Jan 2024 - Jul 2024):")
for key, value in medium_term_metrics.items():
    print(f"{key}: {value:.4f}")

print("\nLong-Term Test Metrics (Jan 2024 - Oct 2024):")
for key, value in long_term_metrics.items():
    print(f"{key}: {value:.4f}")

# Function to plot results
def plot_results(results, title):
    plt.figure(figsize=(12, 6))
    plt.plot(results.index, results['Open'], label='Actual', color='blue')
    plt.plot(results.index, results['Predicted'], label='Predicted', color='red', linestyle='--')
    plt.title(title)
    plt.xlabel('Date')
    plt.ylabel('Stock Price ($)')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

# Plot validation results
plot_results(val_results, f'AAPL Stock Price Validation (Aug 2021 - Dec 2023)\nRMSE: {val_metrics["RMSE"]:.2f}, R²: {val_metrics["R2"]:.2f}')

# Plot test results
plot_results(short_term_results, f'AAPL Stock Price Short-Term Test (Jan 2024 - Mar 2024)\nRMSE: {short_term_metrics["RMSE"]:.2f}, R²: {short_term_metrics["R2"]:.2f}')
plot_results(medium_term_results, f'AAPL Stock Price Medium-Term Test (Jan 2024 - Jul 2024)\nRMSE: {medium_term_metrics["RMSE"]:.2f}, R²: {medium_term_metrics["R2"]:.2f}')
plot_results(long_term_results, f'AAPL Stock Price Long-Term Test (Jan 2024 - Oct 2024)\nRMSE: {long_term_metrics["RMSE"]:.2f}, R²: {long_term_metrics["R2"]:.2f}')